#!/usr/bin/env bash

# Make sure we're in the right directory.
cd "$(git rev-parse --show-toplevel)" || exit -1

# Extract tags from the frontmatter of a file.
# `tags:`` supports multiple space-seperated tags
# `tag:` is one tag per occurance, but alows spaces in the tag.
extract() {
    sed -nE '
/^---$/!q;n;
:next
/^---$/q
/^tags:/{
    s/^tags:[ ]*//
    s/[ ]*$//
    s/[ ]+/\
/g
    p
    n
:nextTag
/^[ ]+-/!q
{
    s/^[ ]+-[ ]*//
    s/[ ]*$//
    p
    n
    bnextTag
    }
}
/^tag:/{
    s/^tag:[ ]*//
    s/[ ]*$//
    p
}
n
bnext
' "$*" | egrep -v '^$'
}

# Scan a directory for .md files to process
scan() {
    if [[ -d "$1" ]]; then
        find "$1" -name '*.md' -print
    fi
}

# Collect the tags from our candidate files.
# These are currently *.md in the root and under _posts/ and pages/
# This won't handle subdirs used to denote post categories.
collect() {
    (ls *.md ; scan _posts ; scan pages) | (
        while read fn; do
            extract "${fn}"
        done;
    ) | sort | uniq
}

# Generate a tag file.
generate() {
    echo "$1"
    echo "---
layout: tagpage
title: \"Tag: $1\"
tag: $1
---
" >"tag/$1.md"
}

# Putt it together: Clear the old tag/ directory and create new content.
rm -rf tag
mkdir tag;
collect | (
    while read tag; do
        generate "${tag}"
    done
)
cat >tag/README.md <<EOF
# Autogenerated tag/ Directory

## Do not edit; changes will be lost on commit

This directory is regenerated by [bin/tagify](../bin/tagify),
and invoked from a git precommit hook.
EOF